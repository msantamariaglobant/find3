{{ template "header" . }}
<!-- Left Panel -->
<!-- Right Panel -->
<div id="right-panel" class="right-panel">
    <div class="breadcrumbs">
        <div class="col-sm-4">
            <div class="page-header float-left">
                <div class="page-title">
                    <h1>Map of Users</h1>
                </div>
            </div>
        </div>
        <div class="col-sm-8">
            <div class="page-header float-right">
                <div class="page-title">
                    <ol class="breadcrumb text-right">
                        <li class="active" style="text-transform:none;">{{ .Family }}</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>
    <div class="content mt-3">
        {{ with .Message }}
        <div class="col-sm-12">
            <div class="alert  alert-success alert-dismissible fade show" role="alert">
                {{.}}
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
        </div>
        {{ end }} {{ with .ErrorMessage }}
        <div class="col-sm-12">
            <div class="alert  alert-danger alert-dismissible fade show" role="alert">
                {{.}}
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
        </div>
        {{ end }}


    <div class="col-sm-12">
            <div class="card">
                <div class="card-body">
                    <div class="row">
                        <div class="col-sm-12">
                            <h4 class="card-title mb-0">About</h4>
                        </div>
                        <div class="col-sm-12">
                            <p>This map shows location of each individual device in realtime. If there are no devices shown, then there is currently no movement in the devices.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <div class="col-sm-12">
            <div class="card">
                <div class="card-body">
                    <div class="row">
                        <div class="col-sm-8">
                            <h4 class="card-title mb-0">Current locations</h4>
                        </div>
                    </div>

                    <div class="content mt-3">
                        <div id="map" style="height:500px;"></div>
                    </div>
                </div>
            </div>
        </div>


    </div>
    <!-- .content -->
</div>
<!-- /#right-panel -->
<!-- Right Panel -->
<script src="/static/js/lib/data-table/datatables.min.js"></script>
<script src="/static/js/lib/data-table/dataTables.bootstrap.min.js"></script>
<script src="/static/js/lib/data-table/dataTables.buttons.min.js"></script>
<script src="/static/js/lib/data-table/buttons.bootstrap.min.js"></script>
<script src="/static/js/lib/data-table/jszip.min.js"></script>
<script src="/static/js/lib/data-table/pdfmake.min.js"></script>
<script src="/static/js/lib/data-table/vfs_fonts.js"></script>
<script src="/static/js/lib/data-table/buttons.html5.min.js"></script>
<script src="/static/js/lib/data-table/buttons.print.min.js"></script>
<script src="/static/js/lib/data-table/buttons.colVis.min.js"></script>
<script src="/static/js/lib/data-table/datatables-init.js"></script>
<script src="/static/js/jquery.autocomplete.js"></script>
<script type="text/javascript">
function toTitleCase(str)
{
    return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
}
function timeSince(date) {

  var seconds = Math.floor((new Date() - date) / 1000);

  var interval = Math.floor(seconds / 31536000);

  if (interval > 1) {
    return interval + " years";
  }
  interval = Math.floor(seconds / 2592000);
  if (interval > 1) {
    return interval + " months";
  }
  interval = Math.floor(seconds / 86400);
  if (interval > 1) {
    return interval + " days";
  }
  interval = Math.floor(seconds / 3600);
  if (interval > 1) {
    return interval + " hours";
  }
  interval = Math.floor(seconds / 60);
  if (interval > 1) {
    return interval + " minutes";
  }
  return Math.floor(seconds) + " seconds";
}

var date  = new Date();

(function($) {
    var tileLayer = new L.TileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',{
      attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
      maxZoom: 22,
       maxNativeZoom: 20
    });

    var map = new L.Map('map', {
      'center': [{{.Center}}],
      'zoom': 20,
      'layers': [tileLayer]
    });

$.getJSON("/static/laminar9.json", function(geoJSON) {

            var indoorLayer = new L.Indoor(geoJSON, {
                getLevel: function(feature) {
                    if (feature.properties.relations.length === 0)
                        return null;

                    return feature.properties.relations[0].reltags.level;
                },
                onEachFeature: function(feature, layer) {
                    layer.bindPopup(JSON.stringify(feature.properties, null, 4));
                },
                style: function(feature) {
                    var fill = 'white';

                    if (feature.properties.tags.buildingpart === 'corridor') {
                        fill = '#169EC6';
                    } else if (feature.properties.tags.buildingpart === 'verticalpassage') {
                        fill = '#0A485B';
                    }

                    return {
                        fillColor: fill,
                        weight: 1,
                        color: '#666',
                        fillOpacity: 1
                    };
                }
            });

            indoorLayer.setLevel("1");

            indoorLayer.onAdd(map);

        });



    var marker = {}


    function distance( geoA, geoB ){
        var earthR = 6.3781e6; // radio de la tierra en metros.
        var a = [];
        var b = [];
        var M_PI = Math.PI;
  // X
        a[0] = earthR * Math.cos( M_PI*(geoA[0])/180.0 ) * Math.cos( M_PI*(geoA[1])/180.0 );
        b[0] = earthR * Math.cos( M_PI*(geoB[0])/180.0 ) * Math.cos( M_PI*(geoB[1])/180.0 );
  // Y
        a[1] = earthR * Math.cos( M_PI*(geoA[0])/180.0 ) * Math.sin( M_PI*(geoA[1])/180.0 );
        b[1] = earthR * Math.cos( M_PI*(geoB[0])/180.0 ) * Math.sin( M_PI*(geoB[1])/180.0 );
  // Z
        a[2] = earthR * Math.sin( M_PI*(geoA[0])/180.0 );
        b[2] = earthR * Math.sin( M_PI*(geoB[0])/180.0 );

       return Math.sqrt( Math.pow(b[0] - a[0],2) + Math.pow(b[1] - a[1],2) + Math.pow(b[2] - a[2],2));
    }
//distance([-34.5968141019, -58.3712115884], [-34.59681851769943, -58.37099231779576]);

function dbm2meters( matchObj ){
  var power_mW = [];
  for (i = 0; i < 3; i++) {
    power_mW[i] = Math.pow(10, matchObj[i][2]/10);
  }
  // Ahora la parte jodida está en estimar el radio de cada una de las antenas.
  // No tenemos la relación directa de mW de potencia a metros.  (tampoco existe, dicho sea de paso)
  // Pero si tenemos pares de antenas que vieron la misma señal, y sabemos la distancia
  // entre antenas y la potencia de recepción a cada una. El respectivo radio de
  // cada una de las antenas está en la relación de
  // D_a = D * sqrt( P_b / (P_a + P_b) )
  // donde D = distancia entre A y B, P_a potencia de recepción en A, y P_b en B.
  // Tomo todas las antenas de a pares para promediar, y tener una mejor estimación
  // del radio.
  var raddi = [];
  //var antenna = [];
  for (a = 0; a < 3; a++) {
    raddi[a] = 0;
    for (b = 0; b < 3; b++) {
      if ( a != b ) {
        var antennaA = [matchObj[a][0], matchObj[a][1]];
        var antennaB = [matchObj[b][0], matchObj[b][1]];
        var D = distance(antennaA, antennaB);
        raddi[a] += D * Math.sqrt( power_mW[b] / (power_mW[a] + power_mW[b]) );
      }

    }
    raddi[a] = raddi[a] / 2 ;
    //cout << "A[" << a << "] = (lat,lon) =  (" << antenna[a].lat << "," << antenna[a].lon << ")\t";
    //cout << "\tr: " << raddi[a] << endl;
  }
  return raddi;
}

    function iterateClock() {
        $("#timesince").text(timeSince(date));
    }
    setInterval(iterateClock,1000);


    toastr.options = {
        "closeButton": false,
        "debug": false,
        "newestOnTop": false,
        "progressBar": false,
        "positionClass": "toast-top-right",
        "preventDuplicates": false,
        "onclick": null,
        "showDuration": "300",
        "hideDuration": "1000",
        "timeOut": "5000",
        "extendedTimeOut": "1000",
        "showEasing": "swing",
        "hideEasing": "linear",
        "showMethod": "fadeIn",
        "hideMethod": "fadeOut"
    }


String.prototype.hashCode = function() {
  var hash = 0, i, chr;
  if (this.length === 0) return hash;
  for (i = 0; i < this.length; i++) {
    chr   = this.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
};

var socket;

var geoAntenna = [
    { "posLat": -34.596818517699430, "posLong": -58.37099231779576 , "name": "makerspace-sniffer-wifi"},
    { "posLat": -34.596766631836830, "posLong": -58.37109759449960 , "name": "puesto 85-sniffer-wifi"},
    { "posLat": -34.596814101900000, "posLong": -58.37121158840000 , "name": "parquedigital-sniffer-wifi"},
    { "posLat": -34.596933328854654, "posLong": -58.37114721536637 , "name": "puesto40-sniffer-wifi"},
    { "posLat": -34.596802786350900, "posLong": -58.37132591754199 , "name": "chill-sniffer-wifi" }
  ];

const socketMessageListener = (event) => {
  data = JSON.parse(event.data);

  var device = data['sensors']['d']


  if (device != "wifi-cc:cc:cc:cc:cc:cc"){
    return;
  }
  console.log(device);
  var matchObj = [];
  var m = 0;

  for (var i = 0; i < geoAntenna.length; i++) {
      var nameObj = geoAntenna[i];
      // console.log(nameObj);
      var dataObj = data['sensors']['s']['wifi'];
      // console.log(dataObj);
      const keys = Object.keys(dataObj);
      for ( const key of keys ) {
          // console.log(nameObj.name);

          if ( nameObj.name == key ){
              var valuerssi = dataObj[key];
              // console.log(valuerssi);
              matchObj[m] = [ nameObj.posLat, nameObj.posLong, valuerssi];
              m++;
          }
      }
  }
  // console.log(matchObj);

  if (matchObj.length < 3){
    console.log("not enough points");
    return;
  }

  var radiosDataPoints = dbm2meters(matchObj);
  console.log(radiosDataPoints);
  var p1=[matchObj[0][0],matchObj[0][1],radiosDataPoints[0]];
  var p2=[matchObj[1][0],matchObj[1][1],radiosDataPoints[1]];
  var p3=[matchObj[2][0],matchObj[2][1],radiosDataPoints[2]];

  var position=Compute(p1,p2,p3);
  console.log("position: " + position);

  var seenDate = new Date(0);
  seenDate.setUTCMilliseconds(data.sensors.t);
  var popupContent = "Location: " + data['location'] + "<br>Probability: " + Math.round(data['guesses'][0]['probability']*100) + "%" + "<br>Seen at " + seenDate;
  var toolTipContent = device;
  if (!marker.hasOwnProperty(device)) {
      marker[device] = L.marker([ position[0], position[1] ])
      .bindPopup(popupContent)
      .bindTooltip(toolTipContent,
          {permanent: true,
          direction: 'top'
      })
      .addTo(map);
  } else {
      marker[device]
          .setPopupContent(popupContent)
          .setTooltipContent(toolTipContent)
          .setLatLng(new L.LatLng(data['sensors']['gps']['lat']+hashedMove,hashedMove+data['sensors']['gps']['lon']))
          .update();
  }
}

/*const socketMessageListener = (event) => {
    data = JSON.parse(event.data);
    //console.log(data);
    var device = data['sensors']['d']
    console.log(device);
   //  ecef antenna[5];
  var geoAntenna = [
    { "posLat": -34.596818517699430, "posLong": -58.37099231779576 , "name": "makerspace-sniffer-wifi"},
    { "posLat": -34.596766631836830, "posLong": -58.37109759449960 , "name": "puesto 85-sniffer-wifi"},
    { "posLat": -34.596814101900000, "posLong": -58.37121158840000 , "name": "parquedigital-sniffer-wifi"},
    { "posLat": -34.596933328854654, "posLong": -58.37114721536637 , "name": "puesto40-sniffer-wifi"},
    { "posLat": -34.596802786350900, "posLong": -58.37132591754199 , "name": "chill-sniffer-wifi" }
  ];

  //sensors.s.wifi
    if (device == "wifi-cc:cc:cc:cc:cc:cc"){
        var matchObj = [];
        var m = 0;
        for (var i = 0; i < geoAntenna.length; i++) {
            var nameObj = geoAntenna[i]
            console.log(nameObj);
            var dataObj = data['sensors']['s']['wifi'];
            console.log(dataObj);
            for (var j = 0; j < Object.keys(dataObj).length; j++) {
                //dataObj[i]
                console.log(nameObj.name);
                // Object.keys(myObject).length;
                if (dataObj.hasOwnProperty(nameObj.name)){
                    var valuerssi = dataObj;
                    console.log(valuerssi);
                    matchObj[j] = [ nameObj.posLat, nameObj.posLong, valuerssi[nameObj.name]];
                    m++;
                }
            }
        }
    console.log(matchObj);
    if (matchObj.length >= 3){

        var radiosDataPoints = dbm2meters(matchObj);
        console.log(radiosDataPoints);
        var p1=[matchObj[0][0],matchObj[0][1],radiosDataPoints[0]];
        var p2=[matchObj[1][0],matchObj[1][1],radiosDataPoints[1]];
        var p3=[matchObj[2][0],matchObj[2][1],radiosDataPoints[2]];

        var a=Compute(p1,p2,p3);
    //}

    var seenDate = new Date(0);
    seenDate.setUTCMilliseconds(data.sensors.t);
    var popupContent = "Location: " + data['location'] + "<br>Probability: " + Math.round(data['guesses'][0]['probability']*100) + "%" + "<br>Seen at " + seenDate;
    var toolTipContent = device;
    if (!marker.hasOwnProperty(device)) {
        marker[device] = L.marker([

            a[0],
            a[1]

        ])
        .bindPopup(popupContent)
        .bindTooltip(toolTipContent,
            {permanent: true,
            direction: 'top'
        })
        .addTo(map);
    } else {
        marker[device]
            .setPopupContent(popupContent)
            .setTooltipContent(toolTipContent)
            .setLatLng(new L.LatLng(data['sensors']['gps']['lat']+hashedMove,hashedMove+data['sensors']['gps']['lon']))
            .update();
    }
};
};//end si es mayor de 3
};//end if cccc*/
const socketOpenListener = (event) => {
  console.log('Connected');
  socket.send('hello');
};

const socketCloseListener = (event) => {
  if (socket) {
    console.error('Disconnected.');
  }
  var url = window.origin.replace("http", "ws") + '/ws?device=all&family={{.FamilyJS}}';
  socket = new WebSocket(url);
  socket.addEventListener('open', socketOpenListener);
  socket.addEventListener('message', socketMessageListener);
  socket.addEventListener('close', socketCloseListener);
};

socketCloseListener();


})(jQuery);
</script>

<script>




function update_position() {
    $.getJSON('/api/v1/by_location/{{.Family}}', function(data) {
        console.log(data['locations'].length);
        var updatedMarkers = {}
        for (i = 0; i < data['locations'].length; i++) {
            console.log(data['locations'][i])
            console.log(data);
            var locData = data['locations'][i]['location'];
            var devices = []
            for (j = 0; j < data['locations'][i]['devices'].length; j++) {
                devices.push(data['locations'][i]['devices'][j]['device']);
            }
            var popupContent = devices.join(", ");
            var toolTipContent = locData + ': ' + data['locations'][i]['devices'].length + " devices";

            if (!marker.hasOwnProperty(locData)) {
                marker[locData] = L.marker([
                    data['locations'][i]['gps']['lat'],
                    data['locations'][i]['gps']['lon']
                ])
                .bindPopup(popupContent)
                .bindTooltip(toolTipContent,
                    {permanent: true,
                    direction: 'top'
                })
                .addTo(map);
            } else {
                marker[locData]
                    .setPopupContent(popupContent)
                    .setTooltipContent(toolTipContent)
                    .update();
            }
            updatedMarkers[locData] = true;
        }

        // remove markers for which there were no updates (no devices at them)
        for (key in marker) {
            console.log(marker[key]);
            if (updatedMarkers.hasOwnProperty(key)) {
                continue
            }
            // delete marker
            map.removeLayer(marker[key]);
            delete marker[key];
        }

        setTimeout(update_position, 1000);
    });
}

</script>


{{ template "footer" . }}
